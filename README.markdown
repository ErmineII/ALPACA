ALPACA
======

Language
--------

**ALPACA** stands for **a** **l**anguage for **p**rogramming
**a**rbitrary **c**ellular **a**utomata.

Cellular Automata
-----------------

While [RUBE](http://catseye.tc/node/RUBE.html) was being developed it became
clear to the author that the "bully" approach to writing a complex cellular
automaton would result in a program extremely difficult to understand and even
worse to maintain.

ALPACA was developed in order to have a terse, precise and readable
language in which to express the rules for any given cellular automaton.
It is in ALPACA, then, that [REDGREEN](http://catseye.tc/node/REDGEEN.html),
a successor to RUBE, is written. Being described in ALPACA instead of C,
the source code for REDGREEN is easily a hundred times clearer than the
knotted mess that is RUBE.

Other cellular automata that have been successfully described in ALPACA
include John Conway's famous Game of Life automaton and the lesser-known
WireWorld automaton.

Implementation
--------------

You can download a copy of the ALPACA v0.90 distribution from this web
server. It contains Perl 5 source code, documentation, example ALPACA
descriptions, and example automaton forms to use for them.

The compiler has now been hand-coded in Perl 5 (instead of C
automatically generated by CoCo/R, as was in v0.80) and produces a Perl
program that accepts an automaton form (a start state) as input, in the
form of an ASCII text file, and animates it.

Documentation
-------------

In brief, a description of a Cellular Automaton (CA) in ALPACA consists
of a number of state or class declarations, seperated with semicolons
and ending with a period.

A state declaration defines a state, associates a visual element with it
(currently an ASCII character, possibly someday a colour or graphic) and
is followed by a list of transition rules seperated by commas.

A class declaration defines a class of states. Each state can belong to
many classes, and are listed in overload order. Classes can have their
own rules, and the `is` operator can be used to check for any of the
states of a class instead of a single state.

A transition rule specifies a state to change to and a boolean
expression to evaluate to see if that state should be changed to. The
expression may make use of whether there are a certain minimum number of
neighbours of a state or class, whether neighbours in certain positions
hold a certain state or class, and constant true, false, and random
boolean terms, manipulated by infix boolean operators.

(A more rigorous and complete specification is underway.)

As an example, here is John Conway's Game of Life automaton, expressed
in ALPACA (it's short):

    state Dead  " "
      to Alive when 3 Alive and 5 Dead;
    state Alive "*"
      to Dead when 4 Alive or 7 Dead.

Grammar
-------

Whitespace is ignored between tokens, and comments extend from
`/*` to `*/` and do not nest.

    AlpacaProgram   ::= Entries ".".
    Entries         ::= Entry {";" Entry}.
    Entry           ::= Class | State.
    Class           ::= "class" ClassID {ClassDesignator} [Rules].
    State           ::= "state" StateID [Appearance] {ClassDesignator} [Rules].

    ClassID         ::= identifier.
    StateID         ::= identifier.
    Appearance      ::= character.

    ClassDesignator ::= "is" ClassID.

    Rules           ::= Rule {"," Rule}.
    Rule            ::= "to" StateDesignator "when" Expression.

    Expression      ::= Term {("and" | "or" | "xor") Term}.

    Term            ::= AdjacentcyFunc
                      | "(" Expression ")"
                      | "not" Term
                      | BoolPrimitive
                      | RelationalFunc.

    RelationalFunc  ::= StateDesignator (StateDesignator | ClassDesignator).

    StateDesignator ::= "n" | "^" | "nw" | "^<"
                      | "s" | "v" | "ne" | "^>"
                      | "w" | "<" | "sw" | "v<"
                      | "e" | ">" | "se" | "v>" | "me" | StateID.

    AdjacentcyFunc  ::= ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8")
                        (StateDesignator | ClassDesignator).

    BoolPrimitive   ::= "true" | "false" | "guess".

    character       ::= quote printable-non-quote quote.
    identifier      ::= alpha {alpha | digit}.
